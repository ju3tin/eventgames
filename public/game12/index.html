<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Dance Mirror Challenge</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacOSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #0f0f1a;
      color: white;
      margin: 0;
      padding: 20px;
      text-align: center;
    }
    h1 { margin: 0.4em 0; font-size: 2.4rem; }
    .subtitle { color: #aaa; margin-bottom: 1.5rem; }
    .container {
      display: flex;
      justify-content: center;
      gap: 2rem;
      flex-wrap: wrap;
      max-width: 1400px;
      margin: 1.5rem auto;
    }
    .video-box {
      position: relative;
      width: 100%;
      max-width: 520px;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 8px 30px rgba(0,0,0,0.6);
    }
    .video-box h3 {
      margin: 0.6em 0 0.3em;
      font-size: 1.3rem;
    }
    video, canvas {
      width: 100%;
      height: auto;
      display: block;
      border: 4px solid transparent;
      border-radius: 8px;
    }
    #tutorial-box video { border-color: #4caf50; }
    #user-box video { border-color: #2196f3; }
    canvas { position: absolute; top: 0; left: 0; pointer-events: none; }
    
    #info {
      margin: 1.5rem 0;
      font-size: 1.4rem;
    }
    #current-move {
      font-size: 1.8rem;
      color: #ffeb3b;
      margin: 0.5em 0;
      min-height: 1.4em;
    }
    #score {
      font-size: 3.2rem;
      font-weight: bold;
      color: #00e676;
      margin: 0.4em 0;
    }
    #match-percent {
      font-size: 1.6rem;
      margin: 0.3em 0 1em;
      color: #80deea;
    }
    button {
      padding: 16px 40px;
      font-size: 1.4rem;
      background: linear-gradient(145deg, #ff5722, #f4511e);
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      margin: 1.5rem 0.8rem;
      transition: all 0.2s;
    }
    button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(244,81,30,0.5);
    }
    button:disabled {
      background: #444;
      cursor: not-allowed;
    }
    #status {
      color: #ffcc00;
      font-size: 1.2rem;
      margin: 1rem 0;
      min-height: 1.4em;
    }
  </style>

  <!-- TensorFlow.js & MoveNet -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core@4.22.0/dist/tf-core.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter@4.22.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@4.22.0/dist/tf-backend-webgl.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.3"></script>
</head>
<body>

  <h1>Dance Mirror Challenge</h1>
  <p class="subtitle">
    Mirror the tutorial dancer — the closer you match, the more points you earn!<br>
    The tutorial plays **once**. Match as well as you can.
  </p>

  <div id="status">Loading AI model & webcam… please wait</div>

  <div class="container">
    <div class="video-box" id="tutorial-box">
      <h3>Tutorial (Green Pose)</h3>
      <video id="tutorial-video" playsinline muted>
        <source src="/videos/your-dance-tutorial.mp4" type="video/mp4">
        Your browser does not support video.
      </video>
      <canvas id="tutorial-canvas"></canvas>
    </div>

    <div class="video-box" id="user-box">
      <h3>Your Movement (Cyan Pose)</h3>
      <video id="user-video" autoplay playsinline></video>
      <canvas id="user-canvas"></canvas>
    </div>
  </div>

  <div id="info">
    <div id="current-move">Waiting to start…</div>
    <div id="score">Score: 0</div>
    <div id="match-percent">Match: —</div>
  </div>

  <button id="start-button" disabled>Start Game</button>

  <script>
    // ────────────────────────────────────────────────
    //  Globals
    // ────────────────────────────────────────────────
    let detector = null;
    let gameRunning = false;
    let accumulatedScore = 0;
    let tutorialKeypoints = null;
    let goodHoldCounter = 0;

    const MAX_POINTS_PER_SECOND = 120;
    const GOOD_HOLD_BONUS = 18;
    const HOLD_THRESHOLD_FRAMES = 30; // ~0.5s at 60fps

    const tutorialVideo = document.getElementById('tutorial-video');
    const tutorialCanvas = document.getElementById('tutorial-canvas');
    const tutorialCtx = tutorialCanvas.getContext('2d');

    const userVideo = document.getElementById('user-video');
    const userCanvas = document.getElementById('user-canvas');
    const userCtx = userCanvas.getContext('2d');

    const statusEl   = document.getElementById('status');
    const scoreEl    = document.getElementById('score');
    const matchEl    = document.getElementById('match-percent');
    const moveEl     = document.getElementById('current-move');
    const startBtn   = document.getElementById('start-button');

    // ────────────────────────────────────────────────
    //  Resize canvases when videos are ready
    // ────────────────────────────────────────────────
    function resizeCanvases() {
      if (tutorialVideo.videoWidth) {
        tutorialCanvas.width = tutorialVideo.videoWidth;
        tutorialCanvas.height = tutorialVideo.videoHeight;
      }
      if (userVideo.videoWidth) {
        userCanvas.width = userVideo.videoWidth;
        userCanvas.height = userVideo.videoHeight;
      }
    }

    tutorialVideo.onloadedmetadata = resizeCanvases;
    userVideo.onloadedmetadata = resizeCanvases;

    // ────────────────────────────────────────────────
    //  Initialize TensorFlow & MoveNet
    // ────────────────────────────────────────────────
    async function initTF() {
      try {
        statusEl.textContent = "Initializing AI engine…";
        await tf.setBackend('webgl');
        await tf.ready();

        statusEl.textContent = "Loading MoveNet model…";
        detector = await poseDetection.createDetector(
          poseDetection.SupportedModels.MoveNet,
          { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING }
        );

        statusEl.textContent = "Ready! Allow camera → click Start";
        startBtn.disabled = false;
      } catch (err) {
        console.error(err);
        statusEl.textContent = "Error: " + err.message;
      }
    }

    // ────────────────────────────────────────────────
    //  Start webcam
    // ────────────────────────────────────────────────
    async function initWebcam() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        userVideo.srcObject = stream;
      } catch (err) {
        statusEl.textContent = "Webcam access denied or unavailable.";
        alert("Camera access is required for this game.");
      }
    }

    // ────────────────────────────────────────────────
    //  Start the game
    // ────────────────────────────────────────────────
    async function startGame() {
      if (gameRunning || !detector) return;
      gameRunning = true;
      accumulatedScore = 0;
      tutorialKeypoints = null;
      goodHoldCounter = 0;

      updateUI();

      // Reset & play tutorial video **once**
      tutorialVideo.currentTime = 0;
      tutorialVideo.loop = false;
      tutorialVideo.muted = false; // if your video has sound
      try {
        await tutorialVideo.play();
      } catch (e) {
        console.warn("Autoplay failed:", e);
        statusEl.textContent = "Video autoplay blocked — click anywhere on page first.";
      }

      statusEl.textContent = "Game started! Mirror the dancer →";
      detectLoop();
    }

    // ────────────────────────────────────────────────
    //  Main detection & scoring loop
    // ────────────────────────────────────────────────
    async function detectLoop() {
      if (!gameRunning) return;

      // Tutorial pose (green)
      if (!tutorialVideo.paused && !tutorialVideo.ended && tutorialVideo.readyState >= 2) {
        const poses = await detector.estimatePoses(tutorialVideo);
        if (poses.length > 0) {
          tutorialKeypoints = poses[0].keypoints;
          drawPose(tutorialCtx, poses, '#4caf50'); // green
        }
      }

      // User pose + scoring (cyan)
      if (userVideo.readyState >= 2) {
        const poses = await detector.estimatePoses(userVideo);
        drawPose(userCtx, poses, '#00d4ff'); // cyan

        if (tutorialKeypoints && poses.length > 0) {
          const userKps = poses[0].keypoints;
          const similarity = calculatePoseSimilarity(tutorialKeypoints, userKps);

          // Show real-time match percentage
          matchEl.textContent = `Match: ${(similarity * 100).toFixed(0)}%`;

          // Scoring
          if (similarity > 0.62) {
            const pointsThisFrame = similarity * MAX_POINTS_PER_SECOND / 60;
            accumulatedScore += pointsThisFrame;

            // Bonus for holding very good match
            goodHoldCounter++;
            if (goodHoldCounter >= HOLD_THRESHOLD_FRAMES) {
              accumulatedScore += GOOD_HOLD_BONUS;
              goodHoldCounter = 0; // reset after bonus
            }
          } else {
            goodHoldCounter = 0;
          }

          scoreEl.textContent = `Score: ${Math.round(accumulatedScore)}`;
        }
      }

      requestAnimationFrame(detectLoop);
    }

    // ────────────────────────────────────────────────
    //  Calculate how similar two poses are (0–1)
    // ────────────────────────────────────────────────
    function calculatePoseSimilarity(tKps, uKps) {
      let totalSim = 0;
      let validCount = 0;

      const parts = [
        'left_shoulder','right_shoulder',
        'left_elbow',   'right_elbow',
        'left_wrist',   'right_wrist',
        'left_hip',     'right_hip',
        'left_knee',    'right_knee',
        'left_ankle',   'right_ankle'
      ];

      for (const name of parts) {
        const t = tKps.find(k => k.name === name);
        const u = uKps.find(k => k.name === name);

        if (t?.score > 0.35 && u?.score > 0.35) {
          const tNorm = { x: t.x / tutorialVideo.videoWidth, y: t.y / tutorialVideo.videoHeight };
          const uNorm = { x: u.x / userVideo.videoWidth,     y: u.y / userVideo.videoHeight };

          const dist = Math.hypot(tNorm.x - uNorm.x, tNorm.y - uNorm.y);
          const sim = Math.max(0, 1 - dist * 3.2); // tune multiplier

          totalSim += sim;
          validCount++;
        }
      }

      return validCount > 0 ? totalSim / validCount : 0;
    }

    // ────────────────────────────────────────────────
    //  Draw skeleton
    // ────────────────────────────────────────────────
    function drawPose(ctx, poses, color) {
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      if (poses.length === 0) return;

      const kps = poses[0].keypoints;
      const pairs = poseDetection.util.getAdjacentPairs(poseDetection.SupportedModels.MoveNet);

      // Dots
      kps.forEach(kp => {
        if (kp.score > 0.35) {
          ctx.beginPath();
          ctx.arc(kp.x, kp.y, 6, 0, 2 * Math.PI);
          ctx.fillStyle = color;
          ctx.fill();
        }
      });

      // Lines
      pairs.forEach(([i, j]) => {
        const a = kps[i];
        const b = kps[j];
        if (a.score > 0.35 && b.score > 0.35) {
          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.lineTo(b.x, b.y);
          ctx.lineWidth = 4.5;
          ctx.strokeStyle = color;
          ctx.stroke();
        }
      });
    }

    // ────────────────────────────────────────────────
    //  Game end (when tutorial video finishes)
    // ────────────────────────────────────────────────
    tutorialVideo.onended = () => {
      if (gameRunning) {
        gameRunning = false;
        const final = Math.round(accumulatedScore);
        alert(`Dance finished!\n\nFinal Score: ${final}\nGreat job!`);
        statusEl.textContent = "Game over. Refresh to play again.";
        moveEl.textContent = "Well danced!";
      }
    };

    // ────────────────────────────────────────────────
    //  Init
    // ────────────────────────────────────────────────
    window.addEventListener('load', async () => {
      await initTF();
      await initWebcam();
      startBtn.addEventListener('click', startGame);
    });
  </script>
</body>
</html>